import React, { useState, useEffect, useRef } from "react";
import { filter } from "lodash";
import { useParams } from "react-router";
import { useLocation, Navigate } from "react-router-dom";
import ReactToPrint from "react-to-print";
import { Toaster } from "react-hot-toast";

//material ui
import { makeStyles } from "@material-ui/styles";
import { Typography, Grid, Box, Button } from "@material-ui/core";
import { Pagination } from "@material-ui/lab";
import { FilterList } from "@material-ui/icons";

//components
import VulnerabilityBox from "../components/VulnerabilityBox";
import AlertPopup from "../components/AlertPopup";
import Header from "../components/Header";
import Sidebar from "../components/Sidebar";
import Searchbar from "../components/Searchbar";
import PrintPage from "../components/PrintPage";
import Alert from "../components/Alert";
import CustomDialog from "../components/CustomDialog";

//constants
import { sentences, countPerPage, portals } from "../constants";

//service
import VulnerabilityService from "../services/VulnerabilityService";

const useStyles = makeStyles(() => ({
  buttonStyle: {
    textTransform: "capitalize",

    color: "#FFFFFF",
    padding: "7px",
  },
  gridItemOne: { marginTop: "3vh", paddingLeft: "3vw" },
  gridItemTwo: { paddingLeft: "2vw" },
  gridItemThree: { top: "5vh", paddingLeft: "2vw" },
  gridItemFour: { top: "5vh", marginBottom: "3vh" },
  gridContainerOne: { marginTop: "3vh", marginBottom: "5vh" },
  boxStyle: {
    borderTop: "1px solid #cccccc",
    borderBottom: "1px solid #cccccc",
    padding: "2vh",
  },
  gridContainerTwo: { marginTop: "2vh", marginBottom: "7vh" },
}));

const ViewVulnerabilities = () => {
  const classes = useStyles();
  const [open, setOpen] = useState(true);
  const [errorOpen, setErrorOpen] = useState(false);
  const [clearSearchQuery, setClearSearchQuery] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [filterName, setFilterName] = useState("");
  const [filterShow, setFilterShow] = useState(true);
  const [date, setDate] = useState(null);
  const [page, setPage] = useState(1);
  const [severity, setSeverity] = useState({
    high: false,
    low: false,
    critical: false,
    medium: false,
  });
  const [stateSelected, setStateSelected] = useState("all");
  const [vulnerabilities, setVulnerabilities] = useState([]);

  const { branch, portal } = useParams();
  const location = useLocation();

  const branches = location.state !== null ? location.state.branches : [];

  const localStorageObject = {
    array:
      localStorage.getItem("tempVulnArray") === null
        ? []
        : JSON.parse(localStorage.getItem("tempVulnArray"))["array"],
  };

  const pageStyle = `
  @page {
    size: 30mm 20mm;
  }

  @media all {
    .pagebreak {
      display: none;
    }
  }

  @media print {
    .pagebreak {
      page-break-before: always;
    }
  }
`;

  const componentRef = useRef();

  const addToArray = (vulnerability) => {
    let count = 0;
    for (var i = 0; i < localStorageObject.array.length; i++) {
      if (localStorageObject.array[i]["id"] !== vulnerability.id) {
        count++;
      } else if (
        localStorageObject.array[i]["commentAdded"] !==
          vulnerability.commentAdded ||
        localStorageObject.array[i]["currentState"] !==
          vulnerability.currentState
      ) {
        localStorageObject.array.splice(i, 1);
        localStorageObject.array.push(vulnerability);
        localStorage.setItem(
          "tempVulnArray",
          JSON.stringify(localStorageObject)
        );

        break;
      }
    }
    if (count === localStorageObject.array.length) {
      localStorageObject.array.push(vulnerability);
      localStorage.setItem("tempVulnArray", JSON.stringify(localStorageObject));
    }
  };

  const handleClearSearchQuery = () => {
    setSearchQuery("");
    setFilterName("");
    setClearSearchQuery(false);
  };

  const handleSearchQuery = (event) => {
    setSearchQuery(event.target.value);
  };

  const handleClick = () => {
    try {
      VulnerabilityService.editVulnerability(
        localStorageObject.array,
        portal,
        branch
      ).then((response) => {
        localStorage.removeItem("tempVulnArray");

        Alert.success("Made Changes Successfully");
      });
    } catch (error) {
      console.log(error);
    }
  };

  const handleChange = (event) => {
    setStateSelected(event.target.value);
  };

  const handleFilterByName = () => {
    setFilterName(searchQuery);
    setClearSearchQuery(true);
  };

  const handleFilterShow = () => {
    setFilterShow(!filterShow);
  };

  const handleChangeCheckBox = (event) => {
    setSeverity({ ...severity, [event.target.name]: event.target.checked });
  };

  const handlePageChange = (e, page) => {
    setPage(page);
  };

  const metadataForVuln = (vulnerability) => {
    return {
      id: vulnerability.id,
      description: vulnerability.description,
      fixedIn: vulnerability.fixedIn,
      identifiers: vulnerability.identifiers,
      moduleName: vulnerability.moduleName,
      severity: vulnerability.severity,
      title: vulnerability.title,
      version: vulnerability.version,
      state: vulnerability.state,
      comment: vulnerability.comment,
      cvssScore: vulnerability.cvssScore,
      saved: vulnerability.savedChange,
    };
  };
  const groupVulnerabilities = (vulnerabilities) => {
    const result = {};
    let uniqueCount = 0;
    let pathsCount = 0;

    if (vulnerabilities && Array.isArray(vulnerabilities)) {
      vulnerabilities.map((vulnerability) => {
        if (!result[vulnerability.id]) {
          result[vulnerability.id] = {
            list: [vulnerability],
            metadata: metadataForVuln(vulnerability),
          };
          pathsCount++;
          uniqueCount++;
        } else {
          result[vulnerability.id].list.push(vulnerability);
          pathsCount++;
        }
      });
    }

    return {
      vulnerabilitiesObject: result,
      vulnerabilitiesUniqueCount: uniqueCount,
      vulnerabilitiesPathsCount: pathsCount,
    };
  };

  useEffect(() => {
    const fetchDate = async () => {
      try {
        if (portal !== "") {
          const response = await VulnerabilityService.getLastModifiedTime(
            portal,
            branch
          );
          setDate(response.data);
        }
      } catch (error) {
        console.log(error);
      }
    };
    fetchDate();
    const filterData = (vulnerabilities) => {
      if (stateSelected === "all") {
        return vulnerabilities.filter((el) => {
          return severity[`${el.severity}`] === true;
        });
      } else {
        const vulnerabilityArray = vulnerabilities.filter((el) => {
          return (
            el.state === stateSelected && severity[`${el.severity}`] === true
          );
        });
        return vulnerabilityArray;
      }
    };

    const filterDataFirstTime = (vulnerabilities) => {
      if (stateSelected === "all") {
        return vulnerabilities;
      } else {
        const vulnerabilityArray = vulnerabilities.filter((el) => {
          return el.state === stateSelected;
        });
        return vulnerabilityArray;
      }
    };

    const fetchData = async () => {
      try {
        const response = await VulnerabilityService.getVulnerabilitiesByPortal(
          portal,
          branch
        );

        if (
          JSON.stringify(severity) ===
          JSON.stringify({
            high: false,
            low: false,
            critical: false,
            medium: false,
          })
        ) {
          if (filterName !== "") {
            setVulnerabilities(
              filter(
                filterDataFirstTime(response.data),
                (_vulnerability) =>
                  _vulnerability.moduleName
                    .toLowerCase()
                    .indexOf(filterName.toLowerCase()) !== -1
              )
            );
          } else {
            setVulnerabilities(filterDataFirstTime(response.data));
          }
        } else {
          if (filterName !== "") {
            setVulnerabilities(
              filter(
                filterData(response.data),
                (_vulnerability) =>
                  _vulnerability.moduleName
                    .toLowerCase()
                    .indexOf(filterName.toLowerCase()) !== -1
              )
            );
          } else {
            setVulnerabilities(filterData(response.data));
          }
        }
      } catch (error) {
        if (error.response) {
          if (error.response.status === 400) {
            setOpen(false);
            setErrorOpen(true);
          }
        }
      }
    };
    fetchData();
  }, [stateSelected, portal, page, severity, filterName, branch]);

  const { vulnerabilitiesObject, vulnerabilitiesUniqueCount } =
    groupVulnerabilities(vulnerabilities);

  const count =
    (vulnerabilitiesUniqueCount - (vulnerabilitiesUniqueCount % 10)) / 10 + 1;

  const paginate = () => {
    let vulnerabilitiesArray;
    if (page * countPerPage > vulnerabilitiesUniqueCount) {
      vulnerabilitiesArray = Object.entries(vulnerabilitiesObject).slice(
        (page - 1) * countPerPage,
        vulnerabilitiesUniqueCount
      );
    } else {
      vulnerabilitiesArray = Object.entries(vulnerabilitiesObject).slice(
        (page - 1) * countPerPage,
        page * countPerPage
      );
    }
    return vulnerabilitiesArray;
  };

  const tempVulnArray =
    JSON.parse(localStorage.getItem("tempVulnArray")) === null
      ? null
      : JSON.parse(localStorage.getItem("tempVulnArray")).array;
  if (tempVulnArray !== null) {
    for (var i = 0; i < tempVulnArray.length; i++) {
      if (vulnerabilitiesObject[tempVulnArray[i]["id"]]) {
        vulnerabilitiesObject[tempVulnArray[i]["id"]]["metadata"] = {
          ...vulnerabilitiesObject[tempVulnArray[i]["id"]]["metadata"],
          comment: tempVulnArray[i]["commentAdded"],
          state: tempVulnArray[i]["currentState"],
          saved: tempVulnArray[i]["savedChange"],
        };
      }
    }
  }

  const vulnComponents = [];
  const vulnerabilitiesArray = paginate();

  for (i = 0; i < vulnerabilitiesArray.length; i++) {
    vulnComponents.push(
      <VulnerabilityBox
        key={vulnerabilitiesArray[i][0]}
        vulnerability={vulnerabilitiesArray[i][1]}
        addToArray={addToArray}
      />
    );
  }
  if (portals.includes(portal) && branches.includes(branch)) {
    if (errorOpen) {
      return (
        <CustomDialog
          open={errorOpen}
          setOpen={setErrorOpen}
          title="Json File Not Found"
          redirect="Home"
        >
          <Typography variant="h6" component="div" style={{ flexGrow: 1 }}>
            {branch === "main"
              ? `${portal}.json file was not found.You need to run CLI to scan ${portal} of main branch for the first time.`
              : `${portal}_${branch}.json file was not found.You need to run CLI to scan ${portal} of ${branch} branch for the first time.`}
          </Typography>
        </CustomDialog>
      );
    } else if (open) {
      return (
        <AlertPopup
          open={open}
          setOpen={setOpen}
          portal={portal}
          date={date}
          branch={branch}
        />
      );
    } else {
      return (
        <>
          <Header portal={portal} branch={branch} />

          <div>
            <Toaster />
          </div>

          <Grid container>
            <Grid item xs={2} md={2} className={classes.gridItemOne}>
              <Button onClick={handleFilterShow}>
                <FilterList />
              </Button>
            </Grid>
            <Grid item xs={10} md={9} className={classes.gridItemTwo}>
              <Grid container className={classes.gridContainerOne}>
                <Searchbar
                  clearSearchQuery={clearSearchQuery}
                  handleClearSearchQuery={handleClearSearchQuery}
                  searchQuery={searchQuery}
                  handleSearchQuery={handleSearchQuery}
                  handleFilterByName={handleFilterByName}
                />
                <Grid lg={2} md={3}></Grid>
                <Grid item xs={6} md={2}>
                  <ReactToPrint
                    pageStyle={pageStyle}
                    //pageStyle="@page { size: 2in 3in }"
                    trigger={() => (
                      <Button
                        className={classes.buttonStyle}
                        color="primary"
                        variant="contained"
                      >
                        Generate Report
                      </Button>
                    )}
                    content={() => componentRef.current}
                    documentTitle={`VulnerabilitiesReport_${portal}_${branch}_${stateSelected}`}
                  />
                  <div style={{ display: "none" }}>
                    <PrintPage
                      ref={componentRef}
                      vulnerabilities={vulnerabilitiesObject}
                      state={stateSelected}
                    />
                  </div>
                </Grid>
              </Grid>
            </Grid>
            <Grid container>
              {filterShow && (
                <Sidebar
                  count={vulnerabilitiesUniqueCount}
                  state={stateSelected}
                  handleChangeCheckBox={handleChangeCheckBox}
                  handleChange={handleChange}
                  severity={severity}
                />
              )}
              <Grid
                item
                xs={11}
                md={filterShow ? 9 : 11}
                className={classes.gridItemThree}
              >
                <Grid item xs={12} className={classes.gridItemFour}>
                  <Box className={classes.boxStyle}>
                    <Typography variant="h5">
                      <b>{portal[0].toUpperCase() + portal.substring(1)}</b>
                    </Typography>
                    <Typography variant="h6">
                      <i>{sentences[`${portal}`]}</i>
                    </Typography>
                  </Box>
                </Grid>
                {vulnComponents}

                {JSON.stringify(vulnerabilitiesObject) === "{}" ? (
                  <div>
                    {" "}
                    <Typography align="center" variant="h4">
                      No results found.
                    </Typography>
                    <Typography align="center" variant="h6">
                      Try adjusting filter options
                    </Typography>
                  </div>
                ) : (
                  <Grid container className={classes.gridContainerTwo}>
                    <Grid item xs={5}>
                      <Pagination
                        count={count}
                        page={page}
                        onChange={handlePageChange}
                        color="primary"
                        variant="outlined"
                      />
                    </Grid>
                    <Grid item xs={4}></Grid>
                    <Grid item xs={2}>
                      <Button
                        className={classes.buttonStyle}
                        onClick={handleClick}
                        variant="contained"
                        color="primary"
                      >
                        Make Changes
                      </Button>
                    </Grid>
                  </Grid>
                )}
              </Grid>
            </Grid>
          </Grid>
        </>
      );
    }
  } else {
    return <Navigate to="/404" replace />;
  }
};

export default ViewVulnerabilities;
