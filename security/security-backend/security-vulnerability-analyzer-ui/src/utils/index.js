import { marked } from "marked";
import sanitizeHtml from "sanitize-html";

export default class Utils {
  static defaultRemediationText =
    "## Remediation\nThere is no remediation at the moment";
  static defaultFixedInText = "No Fix Found";

  /**
   * Get an array of array which contains the arrays containing the modules in the vulnerable path in order.
   * @param {(String[])[]} vulnerabilityArray -an array containing details of a vulnerability of a module by grouping various vulnerable paths
   * @returns {(String[])[]} -an array containg an array of modules involved in a vulnerable path in order
   */
  static getFrom = (list) => {
    if (list.length === 1) {
      return [list[0]["from"]];
    } else {
      let fromArray = [];
      list.forEach((value, index, array) => {
        fromArray.push(value["from"]);
      });
      return fromArray;
    }
  };

  /**
   * Get path from which the vulnerability is introduced.
   * @param {String[]} from - an array which contains modules involved in a vulnerable path in order
   * @returns {String} - a string which explains the path through the vulnerability is introduced
   */
  static findIntroducedPath = (from) => {
    return from.join(">").toString();
  };

  /**
   * Get an array of identifiers of a vulnerabilty
   * @param {Object} identifiers -a javascript object containing identifiers of a vulnerbility(CVE,CWE,SNYK etc)
   * @returns {String[]} - an array of string containing identifiers without null value
   */
  static getIdentifiers = (identifiers) => {
    let identifiersArray = [];
    for (var key in identifiers) {
      if (identifiers[key] !== null) {
        identifiersArray.push(identifiers[key]);
      }
    }
    return identifiersArray;
  };

  /**
   * Get overview about how the module is vulnerable to a vulnerability
   * @param {String} description - a markdown consisiting overview and other details about a vulnerability
   * @returns {String} a markdown consisting overview about how the module is vulnerable to a certain vulnerability
   */
  static getOverview = (description) => {
    const indexDetail = description.indexOf("## Details");
    const indexPoc = description.indexOf("## PoC");

    const indexMin = Math.min(indexDetail, indexPoc);

    if (indexMin !== -1) {
      return sanitizeHtml(marked.parse(description.substring(0, indexMin)));
    } else {
      return sanitizeHtml(marked.parse(description.substring(0, indexDetail)));
    }
  };

  /**
   * Get remediation to get rid of the vulnerability
   * @param {String} description - a markdown consisiting overview and other details about a vulnerability
   * @param {String} fixedIn  - an array of versions in which vulnerability is fixed
   * @returns {String} - a markdown consisting remediation for the vulnerability
   */
  static getRemediation = (description, fixedIn) => {
    // check remediation in the description
    const index = description.indexOf("## Remediation");

    if (index > -1) {
      return sanitizeHtml(marked.parse(description.substring(index)));
    }
    // if no remediation in description, try to check in `fixedIn` attribute
    if (Array.isArray(fixedIn) && fixedIn.length) {
      const fixedInJoined = fixedIn.join(", ");
      return sanitizeHtml(
        marked.parse(`## Remediation\n Fixed in: ${fixedInJoined}`)
      );
    }

    // otherwise, fallback to default message, i.e. No remediation at the moment
    return marked.parse(Utils.defaultRemediationText);
  };

  /**
   * Get the version in which the vulnerability of the given module is fixed
   * @param {String[]} fixedIn - an array of versions in which the vulnerability is fixed
   * @param {String} moduleName - name of the vulnerable module
   * @returns {String} -phrase containing fixed versions of the module
   */
  static getFixedIn = (fixedIn, moduleName) => {
    if (fixedIn.length === 0) {
      return Utils.defaultFixedInText;
    } else if (fixedIn.length === 1) {
      return `${moduleName}@${fixedIn[0]}`;
    } else {
      let fixedInString = moduleName;
      fixedIn.forEach((value, index, array) => {
        fixedInString += `@${value}`;
        if (index !== array.length - 1) {
          fixedInString += ",";
        }
      });

      return fixedInString;
    }
  };
}
